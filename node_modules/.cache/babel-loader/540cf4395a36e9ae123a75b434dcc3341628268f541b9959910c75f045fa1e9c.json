{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\nvar tokens_public_1 = require(\"../scan/tokens_public\");\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function (_a) {\n    var expected = _a.expected,\n      actual = _a.actual,\n      previous = _a.previous,\n      ruleName = _a.ruleName;\n    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    var expectedMsg = hasLabel ? \"--> \".concat((0, tokens_public_1.tokenLabel)(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n    var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function (_a) {\n    var firstRedundant = _a.firstRedundant,\n      ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function (_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n      actual = _a.actual,\n      previous = _a.previous,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\", \"), \"]\");\n      });\n      var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \".concat(idx + 1, \". \").concat(itemMsg);\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function (_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n      actual = _a.actual,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\",\"), \"]\");\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + \"<\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = (0, first_1.default)(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function (rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + \"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function (options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currTok) {\n      return (0, tokens_public_1.tokenLabel)(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\n\") + \"in <OR\".concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function (options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currtok) {\n      return (0, tokens_public_1.tokenLabel)(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \">\") + \" inside <\".concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function (options) {\n    var dslName = (0, gast_2.getProductionDslName)(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\n\") + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function (options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function (options) {\n    var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \">\") + \" in <OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function (options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + \"<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = (0, map_1.default)(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n    var errMsg = \"Left Recursion found in grammar.\\n\" + \"rule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\n\") + \"without consuming any Tokens. The grammar path that causes this is: \\n \".concat(leftRecursivePath, \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function (options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function (options) {\n    var ruleName;\n    if (options.topLevelRule instanceof gast_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n    return errMsg;\n  }\n};","map":{"version":3,"mappings":"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","names":["exports","buildMismatchTokenMessage","_a","expected","actual","previous","ruleName","hasLabel","expectedMsg","name","msg","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","concat","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","gast_1","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildNamespaceConflictError","rule","errMsg","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName"],"sources":["/Users/desarrollo/Desktop/free/node_modules/chevrotain/src/parse/errors_public.ts"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\nimport first from \"lodash/first\"\nimport map from \"lodash/map\"\nimport reduce from \"lodash/reduce\"\nimport { Alternation, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider\n} from \"./grammar/types\"\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected)\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n\n    return msg\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][]\n      )\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \"\n          )}]`\n      )\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\n      )\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\"\n      )}`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\"\n          )}]`\n      )\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  }\n}\n\nObject.freeze(defaultParserErrorProvider)\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\"\n      return msg\n    }\n  }\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[]\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return \"\"\n        }\n      }\n\n      const topLevelName = topLevelRule.name\n      const duplicateProd = first(duplicateProds)!\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \")\n      msg = msg.replace(/\\s\\s+/g, \"\\n\")\n\n      return msg\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n\n      return errMsg\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n\n      return errMsg\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule\n      repetition: IProductionWithOccurrence\n    }): string {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n      emptyChoiceIdx: number\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n\n      return errMsg\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n\n      return errMsg\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule\n      leftRecursionPath: Rule[]\n    }): string {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name\n      )\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string\n      grammarName: string\n    }): string {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n\n      return errMsg\n    }\n  }\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}