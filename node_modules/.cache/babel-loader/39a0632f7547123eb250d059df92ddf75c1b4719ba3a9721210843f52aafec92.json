{"ast":null,"code":"import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n      return nodeObject;\n    }\n  }\n  return obj;\n};\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n  return objects;\n};\nconst getShaderNodeArray = array => {\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n  return array;\n};\nconst ShaderNodeProxy = function (NodeClass) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (scope === null) {\n    return function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\nconst uintsCacheMap = new Map();\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\nconst ConvertType = function (type) {\n  let cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = function () {\n  for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    params[_key5] = arguments[_key5];\n  }\n  return nodeObject(new JoinNode(getShaderNodeArray(params)));\n};\nconst uv = function () {\n  for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    params[_key6] = arguments[_key6];\n  }\n  return nodeObject(new UVNode(...params));\n};\nconst attribute = function () {\n  for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    params[_key7] = arguments[_key7];\n  }\n  return nodeObject(new AttributeNode(...params));\n};\nconst buffer = function () {\n  for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    params[_key8] = arguments[_key8];\n  }\n  return nodeObject(new BufferNode(...params));\n};\nconst texture = function () {\n  for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    params[_key9] = arguments[_key9];\n  }\n  return nodeObject(new TextureNode(...params));\n};\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = function () {\n  for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n    params[_key10] = arguments[_key10];\n  }\n  return nodeObject(new CondNode(...getShaderNodeArray(params)));\n};\nconst addTo = function (varNode) {\n  for (var _len11 = arguments.length, params = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    params[_key11 - 1] = arguments[_key11];\n  }\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };","map":{"version":3,"names":["PropertyNode","VarNode","AttributeNode","ConstNode","UniformNode","BufferNode","PositionNode","NormalNode","CameraNode","ModelNode","TextureNode","UVNode","OperatorNode","CondNode","MathNode","ArrayElementNode","ConvertNode","JoinNode","SplitNode","getValueFromType","NodeHandler","construct","NodeClosure","params","inputs","shift","ShaderNodeObjects","get","node","prop","undefined","test","replace","ShaderNodeObject","uint","Number","nodeObjects","WeakMap","obj","type","getAutoTypedConstNode","isNode","nodeObject","Proxy","set","objects","name","getShaderNodeArray","array","len","length","i","ShaderNodeProxy","NodeClass","scope","factor","ShaderNodeScript","jsFunc","builder","bools","uints","ints","floats","Math","PI","boolsCacheMap","Map","bool","uintsCacheMap","intsCacheMap","map","el","value","int","floatsCacheMap","float","constNodesCacheMap","has","ConvertType","cacheMap","nodes","ShaderNode","val","uniform","_value$node","nodeType","label","isVarNode","temp","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","join","uv","attribute","buffer","texture","sampler","cond","addTo","varNode","add","sub","mul","div","remainder","equal","assign","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","xor","bitAnd","bitOr","bitXor","shiftLeft","shiftRight","element","normalGeometry","GEOMETRY","normalLocal","LOCAL","normalWorld","WORLD","normalView","VIEW","transformedNormalView","positionLocal","positionWorld","positionView","positionViewDirection","VIEW_DIRECTION","viewMatrix","VIEW_MATRIX","cameraPosition","POSITION","diffuseColor","roughness","metalness","alphaTest","specularColor","abs","acos","asin","atan","ceil","clamp","cos","cross","degrees","dFdx","dFdy","distance","dot","exp","exp2","faceforward","floor","fract","invert","inversesqrt","log","log2","max","min","mix","mod","negate","normalize","pow","pow2","pow3","pow4","radians","reflect","refract","round","saturate","sign","sin","smoothstep","sqrt","step","tan","transformDirection","EPSILON","INFINITY"],"sources":["/Users/desarrollo/Desktop/free/node_modules/three-stdlib/nodes/ShaderNode.js"],"sourcesContent":["import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\n\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n\n      return nodeObject;\n    }\n  }\n\n  return obj;\n};\n\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n\n  return objects;\n};\n\nconst getShaderNodeArray = array => {\n  const len = array.length;\n\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n\n  return array;\n};\n\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null) {\n  if (scope === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\n\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\n\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\n\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\n\nconst uintsCacheMap = new Map();\n\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\n\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\n\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\n\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\n\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\n\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\n\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\n\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\n\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));\nconst uv = (...params) => nodeObject(new UVNode(...params));\nconst attribute = (...params) => nodeObject(new AttributeNode(...params));\nconst buffer = (...params) => nodeObject(new BufferNode(...params));\nconst texture = (...params) => nodeObject(new TextureNode(...params));\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));\nconst addTo = (varNode, ...params) => {\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\n\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}