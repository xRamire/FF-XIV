{"ast":null,"code":"import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from 'three';\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n}\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader: /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["Mesh","Color","Vector3","Vector2","Matrix4","PerspectiveCamera","DepthTexture","UnsignedShortType","NearestFilter","WebGLRenderTarget","ShaderMaterial","UniformsUtils","Plane","ReflectorForSSRPass","constructor","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","view","target","textureMatrix","virtualCamera","depthTexture","minFilter","magFilter","parameters","renderTarget","transparent","assign","clone","fragmentShader","vertexShader","texture","globalPlane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","encoding","outputEncoding","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","isReflectorForSSRPass","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["/Users/desarrollo/Desktop/free/node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"sourcesContent":["import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from 'three';\n\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n\n}\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}