{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = exports.validateLookahead = void 0;\nvar first_1 = __importDefault(require(\"lodash/first\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar parser_1 = require(\"../parser/parser\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar lookahead_1 = require(\"./lookahead\");\nvar interpreter_1 = require(\"./interpreter\");\nvar gast_2 = require(\"@chevrotain/gast\");\nvar gast_3 = require(\"@chevrotain/gast\");\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\nvar tokens_1 = require(\"../../scan/tokens\");\nfunction validateLookahead(options) {\n  var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return (0, map_1.default)(lookaheadValidationErrorMessages, function (errorMessage) {\n    return __assign({\n      type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n    }, errorMessage);\n  });\n}\nexports.validateLookahead = validateLookahead;\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nvar OccurrenceValidationCollector = /** @class */function (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n  return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    }\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */function (_super) {\n  __extends(OrCollector, _super);\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.alternations = [];\n    return _this;\n  }\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n  return OrCollector;\n}(gast_3.GAstVisitor);\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetitionCollector = /** @class */function (_super) {\n  __extends(RepetitionCollector, _super);\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allProductions = [];\n    return _this;\n  }\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\nexports.RepetitionCollector = RepetitionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) &&\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx];\n    // ignore (skip) ambiguities with this alternative\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n        // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateLookahead","options","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","tokenTypes","grammarName","errorMessage","type","parser_1","CUSTOM_LOOKAHEAD_VALIDATION","exports","validateGrammar","topLevels","errMsgProvider","duplicateErrors","currTopLevel","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_2","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_3","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","tokens_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","globalMaxLookahead","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/Users/desarrollo/Desktop/free/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType,\n  Rule\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  })\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage\n  }))\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}