{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectMethods = exports.LooksAhead = void 0;\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar has_1 = __importDefault(require(\"lodash/has\"));\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar gast_1 = require(\"@chevrotain/gast\");\nvar gast_2 = require(\"@chevrotain/gast\");\nvar llk_lookahead_1 = require(\"../../grammar/llk_lookahead\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */function () {\n  function LooksAhead() {}\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\") ? config.maxLookahead // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookaheadStrategy = (0, has_1.default)(config, \"lookaheadStrategy\") ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n    : new llk_lookahead_1.LLkLookaheadStrategy({\n      maxLookahead: this.maxLookahead\n    });\n    this.lookAheadFuncsCache = new Map();\n  };\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n    (0, forEach_1.default)(rules, function (currRule) {\n      _this.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n        var _a = collectMethods(currRule),\n          alternation = _a.alternation,\n          repetition = _a.repetition,\n          option = _a.option,\n          repetitionMandatory = _a.repetitionMandatory,\n          repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n          repetitionWithSeparator = _a.repetitionWithSeparator;\n        (0, forEach_1.default)(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          _this.TRACE_INIT(\"\".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function () {\n            var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || _this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: _this.dynamicTokensEnabled\n            });\n            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        (0, forEach_1.default)(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, \"Repetition\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, \"Option\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n      });\n    });\n  };\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n    this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({\n        prodOccurrence: prodOccurrence,\n        rule: rule,\n        maxLookahead: prodMaxLookahead || _this.maxLookahead,\n        dynamicTokensEnabled: _this.dynamicTokensEnabled,\n        prodType: prodType\n      });\n      var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      _this.setLaFuncCache(key, laFunc);\n    });\n  };\n  // this actually returns a number, but it is always used as a string (object prop key)\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n  };\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n  return LooksAhead;\n}();\nexports.LooksAhead = LooksAhead;\nvar DslMethodsCollectorVisitor = /** @class */function (_super) {\n  __extends(DslMethodsCollectorVisitor, _super);\n  function DslMethodsCollectorVisitor() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n    return _this;\n  }\n  DslMethodsCollectorVisitor.prototype.reset = function () {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  };\n  DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n    this.dslMethods.option.push(option);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  };\n  DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n    this.dslMethods.repetition.push(many);\n  };\n  DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n    this.dslMethods.alternation.push(or);\n  };\n  return DslMethodsCollectorVisitor;\n}(gast_1.GAstVisitor);\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  var dslMethods = collectorVisitor.dslMethods;\n  // avoid uncleaned references\n  collectorVisitor.reset();\n  return dslMethods;\n}\nexports.collectMethods = collectMethods;","map":{"version":3,"mappings":"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","names":["LooksAhead","config","dynamicTokensEnabled","parser_1","maxLookahead","lookaheadStrategy","llk_lookahead_1","lookAheadFuncsCache","Map","rules","currRule","_this","TRACE_INIT","name","collectMethods","alternation","repetition","option","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","currProd","prodIdx","idx","laFunc","buildLookaheadForAlternation","prodOccurrence","rule","hasPredicates","key","fullRuleNameToShort","keys_1","setLaFuncCache","computeLookaheadFunc","prodKey","prodType","prodMaxLookahead","dslMethodName","buildLookaheadForOptional","dslMethodIdx","occurrence","currRuleShortName","getLastExplicitRuleShortName","get","value","set","exports","__extends","DslMethodsCollectorVisitor","dslMethods","push","manySep","atLeastOne","atLeastOneSep","many","or","gast_1","collectorVisitor","reset","accept"],"sources":["/Users/desarrollo/Desktop/free/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts"],"sourcesContent":["import forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n  lookaheadStrategy: ILookaheadStrategy\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n\n    this.lookAheadFuncsCache = new Map()\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            })\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType\n        })\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[]\n    alternation: Alternation[]\n    repetition: Repetition[]\n    repetitionWithSeparator: RepetitionWithSeparator[]\n    repetitionMandatory: RepetitionMandatory[]\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(rule: Rule): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}