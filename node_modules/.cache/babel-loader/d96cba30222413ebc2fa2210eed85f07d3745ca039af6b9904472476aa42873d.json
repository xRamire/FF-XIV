{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LLkLookaheadStrategy = void 0;\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar errors_public_1 = require(\"../errors_public\");\nvar parser_1 = require(\"../parser/parser\");\nvar checks_1 = require(\"./checks\");\nvar lookahead_1 = require(\"./lookahead\");\nvar LLkLookaheadStrategy = /** @class */function () {\n  function LLkLookaheadStrategy(options) {\n    var _a;\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  LLkLookaheadStrategy.prototype.validate = function (options) {\n    var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n      var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  };\n  LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n  LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n    return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n  };\n  LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n  };\n  return LLkLookaheadStrategy;\n}();\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAMA;AASA;EAGE,8BAAYA,OAAmC;;IAC7C,IAAI,CAACC,YAAY,GACf,aAAO,aAAPD,OAAO,uBAAPA,OAAO,CAAEC,YAAY,mCAAIC,8BAAqB,CAACD,YAAY;EAC/D;EAEAE,uCAAQ,GAAR,UAASH,OAIR;IACC,IAAMI,mBAAmB,GAAG,IAAI,CAACC,uBAAuB,CAACL,OAAO,CAACM,KAAK,CAAC;IAEvE,IAAI,qBAAO,EAACF,mBAAmB,CAAC,EAAE;MAChC,IAAMG,cAAc,GAAG,IAAI,CAACC,2BAA2B,CAACR,OAAO,CAACM,KAAK,CAAC;MACtE,IAAMG,mBAAmB,GAAG,IAAI,CAACC,wCAAwC,CACvEV,OAAO,CAACM,KAAK,EACb,IAAI,CAACL,YAAY,CAClB;MACD,IAAMU,qBAAqB,GAAG,IAAI,CAACC,iCAAiC,CAClEZ,OAAO,CAACM,KAAK,EACb,IAAI,CAACL,YAAY,CAClB;MACD,IAAMY,SAAS,+DACVT,mBAAmB,SACnBG,cAAc,SACdE,mBAAmB,SACnBE,qBAAqB,OACzB;MACD,OAAOE,SAAS;;IAElB,OAAOT,mBAAmB;EAC5B,CAAC;EAEDD,sDAAuB,GAAvB,UAAwBG,KAAa;IACnC,OAAO,qBAAO,EAACA,KAAK,EAAE,UAACQ,WAAW;MAChC,2CAAuB,EACrBA,WAAW,EACXA,WAAW,EACXC,oDAAoC,CACrC;IAJD,CAIC,CACF;EACH,CAAC;EAEDZ,0DAA2B,GAA3B,UAA4BG,KAAa;IACvC,OAAO,qBAAO,EAACA,KAAK,EAAE,UAACQ,WAAW;MAChC,8CAA0B,EACxBA,WAAW,EACXC,oDAAoC,CACrC;IAHD,CAGC,CACF;EACH,CAAC;EAEDZ,uEAAwC,GAAxC,UACEG,KAAa,EACbL,YAAoB;IAEpB,OAAO,qBAAO,EAACK,KAAK,EAAE,UAACQ,WAAW;MAChC,4DAAwC,EACtCA,WAAW,EACXb,YAAY,EACZc,oDAAoC,CACrC;IAJD,CAIC,CACF;EACH,CAAC;EAEDZ,gEAAiC,GAAjC,UACEG,KAAa,EACbL,YAAoB;IAEpB,OAAO,8CAAiC,EACtCK,KAAK,EACLL,YAAY,EACZc,oDAAoC,CACrC;EACH,CAAC;EAEDZ,2DAA4B,GAA5B,UAA6BH,OAM5B;IACC,OAAO,uCAAuB,EAC5BA,OAAO,CAACgB,cAAc,EACtBhB,OAAO,CAACiB,IAAI,EACZjB,OAAO,CAACC,YAAY,EACpBD,OAAO,CAACkB,aAAa,EACrBlB,OAAO,CAACmB,oBAAoB,EAC5BC,0CAA8B,CAC/B;EACH,CAAC;EAEDjB,wDAAyB,GAAzB,UAA0BH,OAMzB;IACC,OAAO,iDAAiC,EACtCA,OAAO,CAACgB,cAAc,EACtBhB,OAAO,CAACiB,IAAI,EACZjB,OAAO,CAACC,YAAY,EACpBD,OAAO,CAACmB,oBAAoB,EAC5B,2BAAW,EAACnB,OAAO,CAACqB,QAAQ,CAAC,EAC7BD,mDAAuC,CACxC;EACH,CAAC;EACH,2BAAC;AAAD,CAAC,EAhHD;AAAaE","names":["options","maxLookahead","parser_1","LLkLookaheadStrategy","leftRecursionErrors","validateNoLeftRecursion","rules","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","validateAmbiguousAlternationAlternatives","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","allErrors","currTopRule","errors_public_1","prodOccurrence","rule","hasPredicates","dynamicTokensEnabled","lookahead_1","prodType","exports"],"sources":["/Users/desarrollo/Desktop/free/node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts"],"sourcesContent":["import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  Rule,\n  TokenType,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport flatMap from \"lodash/flatMap\"\nimport isEmpty from \"lodash/isEmpty\"\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser\"\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath\n} from \"./checks\"\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType\n} from \"./lookahead\"\nimport { IParserDefinitionError } from \"./types\"\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead\n  }\n\n  validate(options: {\n    rules: Rule[]\n    tokenTypes: TokenType[]\n    grammarName: string\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead\n      )\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead\n      )\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ]\n      return allErrors\n    }\n    return leftRecursionErrors\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider\n    )\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number\n    rule: Rule\n    maxLookahead: number\n    hasPredicates: boolean\n    dynamicTokensEnabled: boolean\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc\n    )\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number\n    prodType: OptionalProductionType\n    rule: Rule\n    maxLookahead: number\n    dynamicTokensEnabled: boolean\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}