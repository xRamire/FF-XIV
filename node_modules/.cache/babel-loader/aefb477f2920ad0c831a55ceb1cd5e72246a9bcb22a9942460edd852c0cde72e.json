{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar every_1 = __importDefault(require(\"lodash/every\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar find_1 = __importDefault(require(\"lodash/find\"));\nvar values_1 = __importDefault(require(\"lodash/values\"));\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) + \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") + \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") + \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            (0, forEach_1.default)(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= lexer_1.minOptimizationVal) {\n                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                    var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return (0, values_1.default)(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return (0, find_1.default)(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return (0, includes_1.default)(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return (0, find_1.default)(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  var quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (0, find_1.default)(pattern, function (char) {\n      return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"mappings":"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","names":["complementErrorMessage","exports","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","regexp_to_ast_1","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","lexer_1","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","__extends","_super","_this","CharCodeFinder","node","found","visitLookahead","visitNegativeLookahead","visitChildren","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["/Users/desarrollo/Desktop/free/node_modules/chevrotain/src/scan/reg_exp.ts"],"sourcesContent":["import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n  Term,\n  VERSION\n} from \"regexp-to-ast\"\nimport isArray from \"lodash/isArray\"\nimport every from \"lodash/every\"\nimport forEach from \"lodash/forEach\"\nimport find from \"lodash/find\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\"\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code as any\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number }\n) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier\n  if (quantifier && quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}